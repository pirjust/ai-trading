# AI量化交易系统 - 接口对接和配置详解

## 1. 交易所API接口详细配置

### 1.1 币安(Binance)API配置

#### 1.1.1 API密钥申请步骤
1. **登录币安官网**: https://www.binance.com
2. **进入API管理**: 用户中心 → API管理
3. **创建API密钥**: 
   - 设置API标签（如：ai-trading-system）
   - 启用交易权限（必须）
   - 启用提现权限（可选，建议不启用）
4. **IP白名单设置**: 添加服务器公网IP
5. **安全验证**: 完成邮箱/手机验证

#### 1.1.2 环境变量配置
```bash
# 在.env文件中配置
BINANCE_API_KEY=your_binance_api_key_here
BINANCE_API_SECRET=your_binance_secret_here
BINANCE_SANDBOX=false
BINANCE_TESTNET=false
```

#### 1.1.3 连接测试代码
```python
# 测试币安连接
import ccxt

def test_binance_connection():
    try:
        exchange = ccxt.binance({
            'apiKey': os.getenv('BINANCE_API_KEY'),
            'secret': os.getenv('BINANCE_API_SECRET'),
            'sandbox': False,
            'options': {
                'defaultType': 'spot',
                'adjustForTimeDifference': True,
                'recvWindow': 60000
            }
        })
        
        # 测试连接
        markets = exchange.fetch_markets()
        balance = exchange.fetch_balance()
        
        print("✅ 币安连接成功")
        print(f"支持交易对数量: {len(markets)}")
        print(f"账户余额: {balance['total'].get('USDT', 0)} USDT")
        
        return True
    except Exception as e:
        print(f"❌ 币安连接失败: {e}")
        return False
```

### 1.2 欧意(OKX)API配置

#### 1.2.1 API密钥申请步骤
1. **登录欧意官网**: https://www.okx.com
2. **进入API管理**: 资产 → API管理
3. **创建API密钥**:
   - 设置API名称（如：ai-trading）
   - 设置交易密码（Passphrase）
   - 选择权限：交易、行情、账户
4. **IP绑定**: 绑定服务器IP
5. **安全设置**: 设置API密钥有效期

#### 1.2.2 环境变量配置
```bash
OKX_API_KEY=your_okx_api_key
OKX_API_SECRET=your_okx_secret
OKX_PASSPHRASE=your_okx_passphrase
OKX_SANDBOX=false
```

#### 1.2.3 连接测试代码
```python
def test_okx_connection():
    try:
        exchange = ccxt.okx({
            'apiKey': os.getenv('OKX_API_KEY'),
            'secret': os.getenv('OKX_API_SECRET'),
            'password': os.getenv('OKX_PASSPHRASE'),
            'sandbox': False
        })
        
        # 测试连接
        markets = exchange.fetch_markets()
        balance = exchange.fetch_balance()
        
        print("✅ OKX连接成功")
        print(f"支持交易对数量: {len(markets)}")
        print(f"账户余额: {balance['total'].get('USDT', 0)} USDT")
        
        return True
    except Exception as e:
        print(f"❌ OKX连接失败: {e}")
        return False
```

### 1.3 Bybit API配置

#### 1.3.1 API密钥申请
1. **登录Bybit**: https://www.bybit.com
2. **API管理**: 账户 → API管理
3. **创建主网API**: 
   - 设置API名称
   - 选择权限：交易、钱包只读
   - 设置IP限制

#### 1.3.2 环境变量配置
```bash
BYBIT_API_KEY=your_bybit_api_key
BYBIT_API_SECRET=your_bybit_secret
BYBIT_SANDBOX=false
```

## 2. 数据API接口配置

### 2.1 Twitter API配置

#### 2.1.1 申请开发者账号
1. **申请开发者账号**: https://developer.twitter.com
2. **创建项目和应用**:
   - 项目名称：AI Trading System
   - 应用名称：Market Data Collector
   - 使用场景：市场数据分析
3. **获取API密钥**:
   - API Key
   - API Secret Key
   - Bearer Token

#### 2.1.2 环境变量配置
```bash
TWITTER_BEARER_TOKEN=your_twitter_bearer_token
TWITTER_API_KEY=your_twitter_api_key
TWITTER_API_SECRET=your_twitter_api_secret
TWITTER_ACCESS_TOKEN=your_twitter_access_token
TWITTER_ACCESS_TOKEN_SECRET=your_twitter_access_token_secret
```

#### 2.1.3 数据采集示例
```python
import tweepy

def collect_twitter_data():
    """收集Twitter市场情绪数据"""
    try:
        client = tweepy.Client(
            bearer_token=os.getenv('TWITTER_BEARER_TOKEN'),
            consumer_key=os.getenv('TWITTER_API_KEY'),
            consumer_secret=os.getenv('TWITTER_API_SECRET'),
            access_token=os.getenv('TWITTER_ACCESS_TOKEN'),
            access_token_secret=os.getenv('TWITTER_ACCESS_TOKEN_SECRET')
        )
        
        # 搜索加密货币相关推文
        query = "(#BTC OR #bitcoin OR #crypto) -is:retweet"
        tweets = client.search_recent_tweets(
            query=query,
            max_results=100,
            tweet_fields=['created_at', 'public_metrics']
        )
        
        sentiment_score = analyze_sentiment(tweets)
        return sentiment_score
        
    except Exception as e:
        print(f"Twitter数据采集失败: {e}")
        return 0
```

### 2.2 Etherscan API配置

#### 2.2.1 申请API密钥
1. **注册Etherscan账号**: https://etherscan.io
2. **申请API密钥**: 用户中心 → API Keys
3. **设置使用限制**: 免费版每日5000次调用

#### 2.2.2 环境变量配置
```bash
ETHERSCAN_API_KEY=your_etherscan_api_key
```

#### 2.2.3 链上数据获取
```python
import requests

def get_eth_gas_price():
    """获取ETH Gas价格"""
    try:
        url = "https://api.etherscan.io/api"
        params = {
            'module': 'gastracker',
            'action': 'gasoracle',
            'apikey': os.getenv('ETHERSCAN_API_KEY')
        }
        
        response = requests.get(url, params=params)
        data = response.json()
        
        if data['status'] == '1':
            return {
                'safe_gas': data['result']['SafeGasPrice'],
                'propose_gas': data['result']['ProposeGasPrice'],
                'fast_gas': data['result']['FastGasPrice']
            }
        return None
        
    except Exception as e:
        print(f"ETH Gas价格获取失败: {e}")
        return None
```

## 3. 数据库连接配置详解

### 3.1 PostgreSQL配置优化

#### 3.1.1 性能优化参数
```sql
-- 连接宝塔面板PostgreSQL进行优化
psql -U postgres

-- 优化配置
ALTER SYSTEM SET shared_buffers = '2GB';
ALTER SYSTEM SET work_mem = '64MB';
ALTER SYSTEM SET maintenance_work_mem = '512MB';
ALTER SYSTEM SET effective_cache_size = '6GB';
ALTER SYSTEM SET max_connections = 200;

-- 重启生效
SELECT pg_reload_conf();
```

#### 3.1.2 表结构优化
```sql
-- 创建优化的交易记录表
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    side VARCHAR(10) NOT NULL,
    price DECIMAL(20,8) NOT NULL,
    amount DECIMAL(20,8) NOT NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    strategy_id INTEGER,
    profit_loss DECIMAL(20,8),
    status VARCHAR(20) DEFAULT 'completed'
);

-- 创建索引
CREATE INDEX idx_trades_symbol_time ON trades(symbol, timestamp);
CREATE INDEX idx_trades_exchange ON trades(exchange);
CREATE INDEX idx_trades_strategy ON trades(strategy_id);
CREATE INDEX idx_trades_timestamp ON trades(timestamp DESC);
```

### 3.2 Redis配置优化

#### 3.2.1 Redis配置优化
```bash
# 编辑Redis配置文件
cat >> /etc/redis/redis.conf << 'EOF'
# 内存优化
maxmemory 2gb
maxmemory-policy allkeys-lru

# 持久化配置
save 900 1
save 300 10
save 60 10000

# 性能优化
hz 10
activerehashing yes

# 网络优化
tcp-keepalive 300
timeout 0

# 安全配置
requirepass your_redis_password_123
bind 0.0.0.0
protected-mode no
EOF

# 重启Redis
systemctl restart redis
```

#### 3.2.2 Redis连接池配置
```python
import redis
from redis.connection import ConnectionPool

# 创建连接池
redis_pool = ConnectionPool(
    host='localhost',
    port=6379,
    password='your_redis_password_123',
    max_connections=50,
    decode_responses=True
)

# 获取Redis连接
def get_redis_client():
    return redis.Redis(connection_pool=redis_pool)

# 使用示例
redis_client = get_redis_client()
redis_client.set('market:btcusdt:price', '45000.00', ex=60)  # 60秒过期
```

## 4. 宝塔面板配置详细步骤

### 4.1 网站配置详细步骤

#### 4.1.1 创建网站
1. **登录宝塔面板**
2. **网站 → 添加站点**
3. **填写域名信息**:
   - 域名：your-domain.com（或服务器IP）
   - 根目录：`/www/wwwroot/ai-trading`
   - FTP：不创建
   - 数据库：选择MySQL/PostgreSQL
4. **PHP版本**：选择纯静态

#### 4.1.2 SSL证书配置
1. **进入网站设置** → **SSL**
2. **选择Let's Encrypt**
3. **勾选域名**：your-domain.com, www.your-domain.com
4. **申请证书**
5. **强制HTTPS**：勾选启用

#### 4.1.3 反向代理配置
在网站设置 → 反向代理中添加：

```nginx
# API接口代理
location /api/ {
    proxy_pass http://127.0.0.1:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # 超时设置
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;
}

# WebSocket代理
location /ws/ {
    proxy_pass http://127.0.0.1:8000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400s;
}
```

### 4.2 防火墙和安全配置

#### 4.2.1 宝塔防火墙配置
1. **安全 → 防火墙**
2. **添加端口规则**:
   - 22 (SSH) - 限制特定IP访问
   - 80 (HTTP) - 开放
   - 443 (HTTPS) - 开放
   - 8000 (应用) - 仅限本地访问
3. **设置IP白名单**

#### 4.2.2 系统防火墙配置
```bash
# 启用防火墙
ufw enable

# 开放必要端口
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw allow 8000/tcp  # 应用端口

# 限制SSH访问（可选）
ufw allow from 192.168.1.0/24 to any port 22

# 查看状态
ufw status verbose
```

## 5. Docker部署错误预防

### 5.1 常见错误及解决方案

#### 5.1.1 端口冲突错误
**错误信息**: `Bind for 0.0.0.0:8000 failed: port is already allocated`

**解决方案**:
```bash
# 检查端口占用
netstat -tulpn | grep :8000

# 停止占用进程
sudo kill -9 <PID>

# 或者修改应用端口
# 编辑 .env 文件
WEB_PORT=8001

# 更新Nginx配置
proxy_pass http://127.0.0.1:8001;
```

#### 5.1.2 数据库连接错误
**错误信息**: `Connection refused` 或 `Authentication failed`

**解决方案**:
```bash
# 检查数据库服务状态
systemctl status postgresql
systemctl status redis

# 检查连接配置
psql -h localhost -U postgres -c "\l"

# 重置数据库密码
sudo -u postgres psql -c "ALTER USER ai_trader PASSWORD 'new_password';"

# 检查防火墙
ufw status
```

#### 5.1.3 内存不足错误
**错误信息**: `Cannot allocate memory` 或容器频繁重启

**解决方案**:
```bash
# 查看内存使用
free -h

# 增加交换空间
sudo fallocate -l 4G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile

# 优化Docker内存限制
docker update --memory=2g --memory-swap=4g ai_trading_web

# 优化系统内存配置
echo 'vm.swappiness=10' >> /etc/sysctl.conf
sysctl -p
```

### 5.2 部署前检查清单

#### 5.2.1 环境检查脚本
```bash
#!/bin/bash
# deploy_check.sh

echo "=== 部署前环境检查 ==="

# 检查Docker
echo "1. 检查Docker..."
docker --version && echo "✅ Docker已安装" || echo "❌ Docker未安装"

# 检查Docker Compose
echo "2. 检查Docker Compose..."
docker-compose --version && echo "✅ Docker Compose已安装" || echo "❌ Docker Compose未安装"

# 检查端口占用
echo "3. 检查端口占用..."
for port in 80 443 8000 5432 6379; do
    if netstat -tulpn | grep ":$port " > /dev/null; then
        echo "❌ 端口 $port 被占用"
    else
        echo "✅ 端口 $port 可用"
    fi
done

# 检查磁盘空间
echo "4. 检查磁盘空间..."
df -h / && df -h /www/wwwroot

# 检查内存
echo "5. 检查内存..."
free -h

echo "=== 检查完成 ==="
```

#### 5.2.2 依赖检查脚本
```python
# check_dependencies.py
import os
import sys
import subprocess

def check_python_dependencies():
    """检查Python依赖"""
    required_packages = [
        'fastapi', 'uvicorn', 'ccxt', 'pandas', 'numpy',
        'sqlalchemy', 'psycopg2', 'redis', 'requests'
    ]
    
    missing_packages = []
    for package in required_packages:
        try:
            __import__(package)
            print(f"✅ {package}")
        except ImportError:
            missing_packages.append(package)
            print(f"❌ {package}")
    
    if missing_packages:
        print(f"\n缺少依赖包: {missing_packages}")
        print("安装命令: pip install " + " ".join(missing_packages))
        return False
    
    return True

def check_environment_variables():
    """检查环境变量"""
    required_vars = [
        'DB_PASSWORD', 'REDIS_PASSWORD', 'BINANCE_API_KEY',
        'BINANCE_API_SECRET'
    ]
    
    missing_vars = []
    for var in required_vars:
        if not os.getenv(var):
            missing_vars.append(var)
            print(f"❌ {var}")
        else:
            print(f"✅ {var}")
    
    if missing_vars:
        print(f"\n缺少环境变量: {missing_vars}")
        return False
    
    return True

if __name__ == "__main__":
    print("=== 依赖检查 ===")
    success = True
    
    success &= check_python_dependencies()
    success &= check_environment_variables()
    
    if success:
        print("\n✅ 所有依赖检查通过")
        sys.exit(0)
    else:
        print("\n❌ 依赖检查失败")
        sys.exit(1)
```

## 6. 监控和告警配置

### 6.1 Prometheus监控配置

#### 6.1.1 应用指标收集
```python
# monitoring/prometheus_metrics.py
from prometheus_client import Counter, Gauge, Histogram
import time

# 定义指标
trades_counter = Counter('trading_trades_total', 'Total number of trades', ['symbol', 'side'])
profit_gauge = Gauge('trading_profit', 'Current profit/loss', ['strategy'])
order_latency = Histogram('trading_order_latency', 'Order execution latency')

# 在交易执行时更新指标
def record_trade(symbol: str, side: str, profit: float, latency: float):
    trades_counter.labels(symbol=symbol, side=side).inc()
    profit_gauge.labels(strategy='default').set(profit)
    order_latency.observe(latency)
```

#### 6.1.2 自定义监控规则
```yaml
# deploy/prometheus_rules/trading_alerts.yml
groups:
- name: trading_alerts
  rules:
  - alert: HighTradingFrequency
    expr: rate(trading_trades_total[5m]) > 10
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "交易频率过高"
      description: "{{ $labels.symbol }} 交易频率为 {{ $value }} 次/分钟"
  
  - alert: SystemMemoryHigh
    expr: (node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes > 0.9
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "系统内存使用率过高"
      description: "内存使用率 {{ $value | humanizePercentage }}"
```

### 6.2 Grafana仪表板配置

#### 6.2.1 交易监控仪表板
1. **添加数据源**: Prometheus (http://prometheus:9090)
2. **导入预置仪表板**: 
   - 交易性能监控
   - 系统资源监控
   - 风险指标监控
3. **设置告警**: 配置邮件/Webhook通知

#### 6.2.2 自定义查询示例
```sql
-- 交易收益统计
SELECT 
    time_bucket('1 hour', timestamp) as hour,
    symbol,
    sum(profit_loss) as total_profit
FROM trades 
WHERE timestamp > NOW() - INTERVAL '24 hours'
GROUP BY hour, symbol
ORDER BY hour DESC, total_profit DESC
```

## 7. 备份和恢复策略

### 7.1 自动化备份脚本

#### 7.1.1 数据库备份
```bash
#!/bin/bash
# backup_database.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/ai-trading"
LOG_FILE="$BACKUP_DIR/backup.log"

# 创建备份目录
mkdir -p $BACKUP_DIR

# PostgreSQL备份
pg_dump -h localhost -U ai_trader ai_trading | gzip > $BACKUP_DIR/postgres_$DATE.sql.gz

# Redis备份
redis-cli --rdb $BACKUP_DIR/redis_$DATE.rdb

# 应用代码备份
tar -czf $BACKUP_DIR/code_$DATE.tar.gz /www/wwwroot/ai-trading/

# 记录备份日志
echo "$DATE: 备份完成" >> $LOG_FILE

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete
find $BACKUP_DIR -name "*.rdb" -mtime +7 -delete
```

#### 7.1.2 定时备份配置
```bash
# 编辑crontab
crontab -e

# 每天凌晨2点执行备份
0 2 * * * /backup/ai-trading/backup_database.sh

# 每周日执行完整备份
0 3 * * 0 /backup/ai-trading/backup_database.sh full

# 每月1号执行归档备份
0 4 1 * * /backup/ai-trading/backup_database.sh archive
```

### 7.2 灾难恢复流程

#### 7.2.1 数据库恢复
```bash
# 停止应用服务
docker-compose -f docker-compose.prod.yml down

# 恢复PostgreSQL
gunzip -c /backup/ai-trading/postgres_20240119_020000.sql.gz | psql -h localhost -U ai_trader ai_trading

# 恢复Redis
sudo systemctl stop redis
cp /backup/ai-trading/redis_20240119_020000.rdb /var/lib/redis/dump.rdb
sudo systemctl start redis

# 重启应用
docker-compose -f docker-compose.prod.yml up -d
```

## 8. 性能优化建议

### 8.1 数据库优化

#### 8.1.1 查询优化
```sql
-- 避免全表扫描
EXPLAIN ANALYZE SELECT * FROM trades WHERE symbol = 'BTCUSDT' AND timestamp > NOW() - INTERVAL '1 day';

-- 使用索引覆盖查询
CREATE INDEX idx_trading_performance ON trades(symbol, timestamp, profit_loss);

-- 分区表优化
CREATE TABLE trades_2024 PARTITION OF trades FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

#### 8.1.2 连接池优化
```python
# 数据库连接池配置
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    'postgresql://ai_trader:password@localhost/ai_trading',
    poolclass=QueuePool,
    pool_size=20,
    max_overflow=30,
    pool_timeout=30,
    pool_recycle=3600
)
```

### 8.2 应用性能优化

#### 8.2.1 异步处理
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

# 异步数据获取
async def fetch_market_data(symbols):
    tasks = [fetch_symbol_data(symbol) for symbol in symbols]
    return await asyncio.gather(*tasks, return_exceptions=True)

# 线程池处理密集计算
with ThreadPoolExecutor(max_workers=4) as executor:
    results = list(executor.map(complex_calculation, data_chunks))
```

#### 8.2.2 缓存优化
```python
import redis
from functools import wraps

# 缓存装饰器
def cache_result(expire_time=300):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            cache_key = f"{func.__name__}:{args}:{kwargs}"
            cached = redis_client.get(cache_key)
            if cached:
                return cached
            
            result = func(*args, **kwargs)
            redis_client.setex(cache_key, expire_time, result)
            return result
        return wrapper
    return decorator
```

## 9. 安全配置最佳实践

### 9.1 API安全

#### 9.1.1 请求限流
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

# API限流配置
@router.get("/api/trades")
@limiter.limit("100/minute")
async def get_trades(request: Request):
    return {"trades": []}
```

#### 9.1.2 JWT令牌验证
```python
from jose import JWTError, jwt
from datetime import datetime, timedelta

SECRET_KEY = os.getenv('SECRET_KEY')
ALGORITHM = "HS256"

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

### 9.2 系统安全

#### 9.2.1 SSH安全加固
```bash
# 编辑SSH配置
sudo nano /etc/ssh/sshd_config

# 修改以下配置
Port 2222                          # 修改默认端口
PermitRootLogin no                 # 禁止root登录
PasswordAuthentication no          # 禁用密码认证
MaxAuthTries 3                     # 限制认证尝试次数
ClientAliveInterval 300           # 客户端存活检查

# 重启SSH服务
sudo systemctl restart sshd
```

#### 9.2.2 文件权限设置
```bash
# 设置文件权限
chown -R www:www /www/wwwroot/ai-trading
chmod 644 /www/wwwroot/ai-trading/config/*
chmod 600 /www/wwwroot/ai-trading/.env
chmod 700 /www/wwwroot/ai-trading/scripts/*.sh

# 保护敏感文件
chattr +i /www/wwwroot/ai-trading/.env
```

## 10. 故障排除和日志分析

### 10.1 常见问题排查

#### 10.1.1 服务启动失败
```bash
# 查看服务日志
docker-compose -f docker-compose.prod.yml logs web_app

# 检查服务状态
docker-compose -f docker-compose.prod.yml ps

# 检查网络连接
docker network ls
docker network inspect ai-trading_trading_network
```

#### 10.1.2 数据库连接问题
```bash
# 检查数据库连接
psql -h localhost -U ai_trader -d ai_trading -c "SELECT 1;"

# 检查连接数
psql -h localhost -U postgres -c "SELECT count(*) FROM pg_stat_activity;"

# 检查慢查询
psql -h localhost -U postgres -c "SELECT query, total_time FROM pg_stat_statements ORDER BY total_time DESC LIMIT 10;"
```

### 10.2 日志分析工具

#### 10.2.1 实时日志监控
```bash
# 实时查看应用日志
tail -f /www/wwwroot/ai-trading/logs/app.log

# 使用multitail查看多个日志
multitail /www/wwwroot/ai-trading/logs/app.log /www/wwwroot/ai-trading/logs/error.log

# 使用journalctl查看系统日志
journalctl -u ai-trading.service -f
```

#### 10.2.2 错误日志分析脚本
```python
# analyze_logs.py
import re
from collections import Counter

def analyze_error_logs(log_file):
    """分析错误日志"""
    error_patterns = {
        'connection_error': r'.*Connection.*error.*',
        'timeout_error': r'.*Timeout.*',
        'authentication_error': r'.*Authentication.*failed.*',
        'database_error': r'.*Database.*error.*'
    }
    
    error_counts = Counter()
    
    with open(log_file, 'r') as f:
        for line in f:
            for error_type, pattern in error_patterns.items():
                if re.match(pattern, line, re.IGNORECASE):
                    error_counts[error_type] += 1
    
    return error_counts

if __name__ == "__main__":
    errors = analyze_error_logs('/www/wwwroot/ai-trading/logs/error.log')
    for error_type, count in errors.most_common():
        print(f"{error_type}: {count}次")
```

---

## 总结

这份详细的接口对接和配置文档包含了从交易所API配置到系统部署的完整流程，重点解决了以下问题：

1. **接口对接详细步骤**：每个交易所的API申请和配置流程
2. **错误预防机制**：部署前的环境检查和依赖验证
3. **性能优化方案**：数据库、缓存、应用层面的优化策略
4. **安全配置最佳实践**：系统安全和API安全的全方位保护
5. **监控和告警系统**：实时监控和自动告警配置
6. **备份和恢复策略**：数据安全和灾难恢复方案

按照这份文档的步骤操作，可以确保系统部署过程顺利，避免常见的配置错误和性能问题。